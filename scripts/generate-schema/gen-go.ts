import type { Doc, Node } from "./parser.ts";
import { Writer } from "./gen-helpers.ts";
import { match } from "npm:ts-pattern";

const header = (relativePath: string) =>
  `// Code generated by ${relativePath}; DO NOT EDIT.\n` +
  "package webview\n\n" +
  "import (\n" +
  "\t\"encoding/json\"\n" +
  "\t\"fmt\"\n" +
  ")\n\n";

// Track generated definitions to avoid duplicates
const generatedTypeDefinitions = new Set<string>();

export function generateGo(
  doc: Doc,
  name: string,
  relativePath: string,
) {
  // Only include header for the first schema
  const shouldIncludeHeader = generatedTypeDefinitions.size === 0;
  const types = generateTypes(doc, name);
  return (shouldIncludeHeader ? header(relativePath) : "") + types;
}

function generateTypes(doc: Doc, typeName: string) {
  const writer = new Writer();
  const { w, wn } = writer.shorthand();

  // Generate definitions first
  for (const [name, definition] of Object.entries(doc.definitions)) {
    // Skip if we've already generated this definition
    if (generatedTypeDefinitions.has(name)) {
      continue;
    }
    generatedTypeDefinitions.add(name);

    // Special handling for Content type to create polymorphic structure
    if (name === "Content") {
      generateContentTypes();
    } else {
      if (definition.description) {
        wn(`// ${name} ${definition.description}`);
      }
      w("type", name, " ");
      generateNode(definition, name);
      wn("\n");
    }
  }

  // Generate the main type if not already defined
  if (!generatedTypeDefinitions.has(typeName)) {
    // Special handling for Content type to create polymorphic structure
    if (typeName === "Content") {
      generateContentTypes();
    } else {
      if (doc.description) {
        wn(`// ${typeName} ${doc.description}`);
      }
      w("type", typeName, " ");
      generateNode(doc.root, typeName);
      wn("\n");
    }
  }

  function generateNode(node: Node, parentName: string) {
    match(node)
      .with({ type: "reference" }, (node) => w(node.name))
      .with({ type: "int" }, () => w("int"))
      .with({ type: "float" }, () => w("float64"))
      .with({ type: "boolean" }, () => w("bool"))
      .with({ type: "string" }, () => w("string"))
      .with({ type: "literal" }, () => w("string")) // Literals become strings in Go
      .with(
        { type: "record" },
        (node) => w(`map[string]${goType(node.valueType)}`),
      )
      .with({ type: "object" }, (node) => {
        wn("struct {");
        for (const { key, required, description, value } of node.properties) {
          if (description) {
            // Handle multi-line descriptions
            const descLines = description.split('\n');
            for (const line of descLines) {
              wn(`\t// ${capitalizeFirst(key)} ${line}`);
            }
          }
          // Use uppercase for public API structs, lowercase for internal structs
          const fieldName = isPublicAPIStruct(parentName) ? capitalizeFirst(key) : lowercaseFirst(key);
          let fieldType = getGoType(value);
          // Make optional fields pointer types (except for interface{} and map types)
          if (!required && fieldType !== "interface{}" && !fieldType.includes("map[")) {
            fieldType = "*" + fieldType;
          }
          const jsonTag = required ? `\`json:"${key}"\`` : `\`json:"${key},omitempty"\``;
          wn(`\t${fieldName} ${fieldType} ${jsonTag}`);
        }
        w("}");
      })
      .with({ type: "intersection" }, () => {
        // Go doesn't have intersection types, so we'll need to generate a new struct
        // For now, just use interface{}
        w("interface{}")
      })
      .with({ type: "union" }, () => {
        // Go doesn't have union types, so we use interface{}
        w("interface{}")
      })
      .with({ type: "descriminated-union" }, (node) => {
        // For discriminated unions, we'll create separate types for each variant
        // and use interface{} for the main type
        w("interface{}");
        
        // Generate variant types
        for (const [variantName, members] of Object.entries(node.members)) {
          const variantTypeName = `${parentName}${capitalizeFirst(variantName)}`;
          if (!generatedTypeDefinitions.has(variantTypeName)) {
            generatedTypeDefinitions.add(variantTypeName);
            wn("\n");
            wn(`// ${variantTypeName} represents the ${variantName} variant of ${parentName}`);
            wn(`type ${variantTypeName} struct {`);
            wn(`\tType string \`json:"${node.descriminator}"\``);
            for (const { key, required, description, value } of members) {
              if (description) {
                wn(`\t// ${capitalizeFirst(key)} ${description}`);
              }
              // Use uppercase for public API structs, lowercase for internal structs  
              const fieldName = isPublicAPIStruct(parentName) ? capitalizeFirst(key) : lowercaseFirst(key);
              let fieldType = getGoType(value);
              // Make optional fields pointer types (except for interface{} and map types)
              if (!required && fieldType !== "interface{}" && !fieldType.includes("map[")) {
                fieldType = "*" + fieldType;
              }
              const jsonTag = required ? `\`json:"${key}"\`` : `\`json:"${key},omitempty"\``;
              wn(`\t${fieldName} ${fieldType} ${jsonTag}`);
            }
            wn("}");
          }
        }
      })
      .with({ type: "enum" }, () => {
        // Go doesn't have enums, so we use string
        w("string")
      })
      .with({ type: "unknown" }, () => w("interface{}"))
      .exhaustive();
  }

  function generateContentTypes() {
    // Generate the ContentProvider interface
    wn("// ContentProvider interface that all content types must implement");
    wn("type ContentProvider interface {");
    wn("\tisContent() // marker method");
    wn("}");
    wn("");

    // Generate HTMLContent struct
    wn("// HtmlContent represents inline HTML content");
    wn("type HtmlContent struct {");
    wn("\tHtml   string `json:\"html\"`");
    wn("\tOrigin string `json:\"origin,omitempty\"`");
    wn("}");
    wn("");

    // Generate URLContent struct
    wn("// UrlContent represents content loaded from a URL");
    wn("type UrlContent struct {");
    wn("\tUrl     string            `json:\"url\"`");
    wn("\tHeaders map[string]string `json:\"headers,omitempty\"`");
    wn("}");
    wn("");

    // Generate interface implementations
    wn("// Implement ContentProvider interface");
    wn("func (h HtmlContent) isContent() {}");
    wn("func (u UrlContent) isContent()  {}");
    wn("");

    // Generate constructor functions
    wn("// NewHtmlContent creates HtmlContent with the specified HTML and optional origin");
    wn("func NewHtmlContent(html string, origin ...string) HtmlContent {");
    wn("\tc := HtmlContent{Html: html}");
    wn("\tif len(origin) > 0 {");
    wn("\t\tc.Origin = origin[0]");
    wn("\t}");
    wn("\treturn c");
    wn("}");
    wn("");

    wn("// NewUrlContent creates UrlContent with the specified URL and optional headers");
    wn("func NewUrlContent(url string, headers ...map[string]string) UrlContent {");
    wn("\tc := UrlContent{Url: url}");
    wn("\tif len(headers) > 0 {");
    wn("\t\tc.Headers = headers[0]");
    wn("\t}");
    wn("\treturn c");
    wn("}");
    wn("");

    // Generate Content wrapper struct
    wn("// Content wraps a ContentProvider for JSON marshaling");
    wn("type Content struct {");
    wn("\tprovider ContentProvider");
    wn("}");
    wn("");

    // Generate Content constructor function (as a package-level function)
    wn("// ContentFrom creates a new Content from any ContentProvider");
    wn("func ContentFrom(provider ContentProvider) Content {");
    wn("\treturn Content{provider: provider}");
    wn("}");
    wn("");

    // Generate MarshalJSON method
    wn("// MarshalJSON implements custom JSON marshaling for Content");
    wn("func (c Content) MarshalJSON() ([]byte, error) {");
    wn("\treturn json.Marshal(c.provider)");
    wn("}");
    wn("");

    // Generate UnmarshalJSON method
    wn("// UnmarshalJSON implements custom JSON unmarshaling for Content");
    wn("func (c *Content) UnmarshalJSON(data []byte) error {");
    wn("\tvar raw map[string]interface{}");
    wn("\tif err := json.Unmarshal(data, &raw); err != nil {");
    wn("\t\treturn err");
    wn("\t}");
    wn("");
    wn("\tif _, hasURL := raw[\"url\"]; hasURL {");
    wn("\t\tvar content UrlContent");
    wn("\t\tif err := json.Unmarshal(data, &content); err != nil {");
    wn("\t\t\treturn err");
    wn("\t\t}");
    wn("\t\tc.provider = content");
    wn("\t\treturn nil");
    wn("\t}");
    wn("");
    wn("\tif _, hasHTML := raw[\"html\"]; hasHTML {");
    wn("\t\tvar content HtmlContent");
    wn("\t\tif err := json.Unmarshal(data, &content); err != nil {");
    wn("\t\t\treturn err");
    wn("\t\t}");
    wn("\t\tc.provider = content");
    wn("\t\treturn nil");
    wn("\t}");
    wn("");
    wn("\treturn fmt.Errorf(\"unknown content type\")");
    wn("}");
    wn("");
  }

  function getGoType(node: Node): string {
    return match(node)
      .with({ type: "reference" }, (node) => node.name)
      .with({ type: "int" }, () => "int")
      .with({ type: "float" }, () => "float64")
      .with({ type: "boolean" }, () => "bool")
      .with({ type: "string" }, () => "string")
      .with({ type: "literal" }, () => "string")
      .with({ type: "record" }, (node) => `map[string]${goType(node.valueType)}`)
      .with({ type: "object" }, () => "struct { /* inline */ }")
      .with({ type: "intersection" }, () => "interface{}")
      .with({ type: "union" }, () => "interface{}")
      .with({ type: "descriminated-union" }, () => "interface{}")
      .with({ type: "enum" }, () => "string")
      .with({ type: "unknown" }, () => "interface{}")
      .exhaustive();
  }

  function goType(type: string): string {
    switch (type) {
      case "string": return "string";
      case "number": return "float64";
      case "boolean": return "bool";
      default: return "interface{}";
    }
  }

  function capitalizeFirst(str: string): string {
    // Handle snake_case to PascalCase conversion
    return str.split('_').map(part => 
      part.charAt(0).toUpperCase() + part.slice(1)
    ).join('');
  }

  function lowercaseFirst(str: string): string {
    // Handle snake_case to camelCase conversion
    const parts = str.split('_');
    return parts[0].toLowerCase() + parts.slice(1).map(part => 
      part.charAt(0).toUpperCase() + part.slice(1)
    ).join('');
  }

  function isPublicAPIStruct(typeName: string): boolean {
    // Most structs should have exported fields for public API
    // Only internal implementation details should be private
    const privateTypes = [
      'Content' // Content.provider should remain private
    ];
    return !privateTypes.includes(typeName);
  }

  return writer.output();
}