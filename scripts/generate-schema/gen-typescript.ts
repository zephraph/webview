import type { Doc, Node } from "./parser.ts";
import { Writer } from "./gen-helpers.ts";
import { match } from "npm:ts-pattern";

const header = (relativePath: string) =>
  `// DO NOT EDIT: This file is auto-generated by ${relativePath}\n` +
  "import { z } from 'npm:zod';\n\n";

export function generateTypeScript(
  doc: Doc,
  name: string,
  relativePath: string,
) {
  let result = header(relativePath);
  result += generateTypes(doc, name);
  result += generateZodSchema(doc, name);
  return result;
}

function generateTypes(doc: Doc, typeName: string) {
  const writer = new Writer();
  const { w, wn } = writer.shorthand();

  for (const [name, definition] of Object.entries(doc.definitions)) {
    if (definition.description) {
      wn("/**");
      wn(` * ${definition.description}`);
      wn(" */");
    }
    wn("export type", name, " = ");
    generateNode(definition);
    wn("");
  }

  if (doc.description) {
    wn("/**");
    wn(` * ${doc.description}`);
    wn(" */");
  }
  wn("export type", typeName, " = ");
  generateNode(doc.root);
  wn("");

  function generateNode(node: Node) {
    match(node)
      .with({ type: "reference" }, (node) => w(node.name))
      .with({ type: "int" }, () => w("number"))
      .with({ type: "float" }, () => w("number"))
      .with({ type: "boolean" }, () => w("boolean"))
      .with({ type: "string" }, () => w("string"))
      .with({ type: "literal" }, (node) => w(`"${node.value}"`))
      .with(
        { type: "record" },
        (node) => w(`Record<string, ${node.valueType}>`),
      )
      .with({ type: "object" }, (node) => {
        wn("{");
        for (const { key, required, description, value } of node.properties) {
          if (description) {
            if (description.includes("\n")) {
              wn(`/**`);
              for (const line of description.split("\n")) {
                wn(` * ${line}`);
              }
              wn(` */`);
            } else {
              wn(`/** ${description} */`);
            }
          }
          w(key, required ? ": " : "? : ");
          generateNode(value);
          wn(",");
        }
        wn("}");
      })
      .with({ type: "intersection" }, (node) => {
        wn("(");
        for (const member of node.members) {
          w("& ");
          generateNode(member);
        }
        wn(")");
      })
      .with({ type: "union" }, (node) => {
        wn("(");
        for (const member of node.members) {
          generateNode(member);
          if (member !== node.members.at(-1)) {
            w(" | ");
          }
        }
        wn(")");
      })
      .with({ type: "descriminated-union" }, (node) => {
        wn("(");
        for (const [name, member] of Object.entries(node.members)) {
          wn("| {");
          wn(`${node.descriminator}: "${name}",`);
          for (const { key, required, description, value } of member) {
            wn(description ? `/** ${description} */` : "");
            w(key, required ? ": " : "? : ");
            generateNode(value);
            wn(",");
          }
          wn("}");
        }
        wn(")");
      })
      .with({ type: "enum" }, (node) => {
        w("(");
        w(node.members.map((m) => `"${m}"`).join(" | "));
        w(")");
      })
      .with({ type: "unknown" }, () => w("unknown"))
      .exhaustive();
  }
  return writer.output();
}

export function generateZodSchema(doc: Doc, name: string) {
  let result = "";
  const w = (...t: (string | false | undefined | null | 0)[]) => {
    result += t.filter((t) => t).join(" ");
  };
  const wn = (...t: (string | false | undefined | null | 0)[]) => w(...t, "\n");

  for (const [name, definition] of Object.entries(doc.definitions)) {
    wn("export const", name, `: z.ZodType<${name}> =`);
    generateNode(definition);
    wn("");
  }

  wn("export const", name, `: z.ZodType<${name}> =`);
  generateNode(doc.root);
  wn("");

  function generateNode(node: Node) {
    match(node)
      .with({ type: "reference" }, (node) => w(node.name))
      .with({ type: "int" }, (node) => {
        w("z.number().int()");
        if (typeof node.minimum === "number") {
          w(`.min(${node.minimum})`);
        }
        if (typeof node.maximum === "number") {
          w(`.max(${node.maximum})`);
        }
      })
      .with({ type: "float" }, (node) => {
        w("z.number()");
        if (typeof node.minimum === "number") {
          w(`.min(${node.minimum})`);
        }
        if (typeof node.maximum === "number") {
          w(`.max(${node.maximum})`);
        }
      })
      .with(
        { type: "boolean" },
        (node) => w("z.boolean()", node.optional && ".optional()"),
      )
      .with({ type: "string" }, () => w("z.string()"))
      .with({ type: "literal" }, (node) => w(`z.literal("${node.value}")`))
      .with(
        { type: "record" },
        (node) => w(`z.record(z.string(), z.${node.valueType}())`),
      )
      .with({ type: "object" }, (node) => {
        w("z.object({");
        for (const { key, required, value } of node.properties) {
          w(key, ":");
          generateNode(value);
          if (!required && !("optional" in value && value.optional)) {
            w(".optional()");
          }
          w(",");
        }
        wn("})");
      })
      .with({ type: "descriminated-union" }, (node) => {
        w(`z.discriminatedUnion("${node.descriminator}", [`);
        for (const [name, member] of Object.entries(node.members)) {
          w(`z.object({ ${node.descriminator}: z.literal("${name}"),`);
          for (const { key, required, value } of member) {
            w(key, ": ");
            generateNode(value);
            if (!required) {
              w(".optional()");
            }
            wn(",");
          }
          wn("}),");
        }
        wn("])");
      })
      .with({ type: "intersection" }, (node) => {
        w("z.intersection(");
        for (const member of node.members) {
          generateNode(member);
          w(",");
        }
        wn(")");
      })
      .with({ type: "union" }, (node) => {
        w("z.union([");
        for (const member of node.members) {
          generateNode(member);
          w(",");
        }
        wn("])");
      })
      .with({ type: "enum" }, (node) => {
        w("z.enum([");
        w(node.members.map((m) => `"${m}"`).join(", "));
        w("])");
      })
      .with({ type: "unknown" }, () => w("z.unknown()"))
      .exhaustive();
  }

  return result;
}
