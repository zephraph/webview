import { walk } from "https://deno.land/std@0.190.0/fs/walk.ts";
import { basename } from "https://deno.land/std@0.190.0/path/mod.ts";
import { match, P } from "npm:ts-pattern";
import type {
  JSONSchema7 as JSONSchema,
  JSONSchema7Definition as JSONSchemaDefinition,
} from "npm:@types/json-schema";

const schemasDir = new URL("../schemas", import.meta.url).pathname;
const outputFile = new URL("../src/schemas.ts", import.meta.url).pathname;

const isDescriminatedUnion = (def: JSONSchemaDefinition[] | undefined) => {
  return def && typeof def[0] === "object" &&
    def[0]?.required?.includes("$type");
};

function generateZodSchema(schema: JSONSchema) {
  let zodSchema = "";
  const w = (...t: string[]) => {
    zodSchema += t.join(" ");
  };
  const wn = (...t: string[]) => w(...t, "\n");

  match(schema)
    .with(
      { type: "boolean" },
      (schema) =>
        w(
          "z.boolean()" + (schema.default ? `.optional()` : ""),
        ),
    )
    .with({ type: "string", enum: P.array() }, (schema) => {
      w(`z.literal("${schema.enum[0]}")`);
    })
    .with({ type: "string" }, () => w("z.string()"))
    .with({ type: P.array(P.string) }, (schema) => {
      w("z");
      for (const type of schema.type) {
        match(type)
          .with("boolean", () => w(".boolean()"))
          .with("string", () => w(".string()"))
          .with("null", () => w(".nullable()"))
          .otherwise(() => {
            throw new Error(`Unsupported type: ${type}`);
          });
      }
    })
    .with({
      title: P.string,
      oneOf: P.when(isDescriminatedUnion),
    }, (schema) => {
      // @ts-expect-error This is fine, this code path should never be a boolean
      const descrim = schema.oneOf[0]?.required[0];
      wn(`z.discriminatedUnion("${descrim}", [`);
      for (const s of schema.oneOf ?? []) {
        if (typeof s === "boolean") {
          w(`z.boolean(),`);
          continue;
        }
        w(`z.object({`);
        for (const [key, value] of Object.entries(s.properties!)) {
          w(
            `${key}:`,
            typeof value === "boolean"
              ? value.toString()
              : generateZodSchema(value),
            ",",
          );
        }
        // Ensure `data` is always defined in descriminated unions
        if (!("data" in s.properties!)) {
          w("data: z.undefined().optional(),");
        }
        w(`}),`);
      }
      wn("])");
    })
    .with({ title: P.string, oneOf: P.array() }, (schema) => {
      if (schema.properties) {
        wn("z.intersection(");
        wn("z.object({");
        for (const [key, value] of Object.entries(schema.properties!)) {
          const required = schema.required?.includes(key) ?? false;
          w(
            `${key}:`,
            typeof value === "boolean"
              ? value.toString()
              : generateZodSchema(value) + (required ? "" : ".optional()"),
            ",",
          );
        }
        wn("}),");
      }
      wn("z.union([");
      for (const s of schema.oneOf ?? []) {
        if (typeof s === "boolean") {
          w("z.boolean(),");
          continue;
        }
        w(generateZodSchema(s), ",");
      }
      wn("])");
      if (schema.properties) {
        wn(")");
      }
    })
    .with({ type: "object" }, (schema) => {
      wn("z.object({");
      for (const [key, value] of Object.entries(schema.properties!)) {
        const required = schema.required?.includes(key) ?? false;
        w(
          `${key}:`,
          typeof value === "boolean"
            ? value.toString()
            : generateZodSchema(value) + (required ? "" : ".optional()"),
          ",",
        );
      }
      wn("})");
    });

  return zodSchema;
}

async function main() {
  let output =
    "// DO NOT EDIT: This file is auto-generated by scripts/generate-zod.ts\n" +
    "import { z } from 'npm:zod';\n\n";

  for await (const entry of walk(schemasDir, { exts: [".json"] })) {
    if (entry.isFile) {
      const jsonSchema: JSONSchema = JSON.parse(
        await Deno.readTextFile(entry.path),
      );
      const schemaName = basename(entry.path, ".json");
      const schema = await generateZodSchema(jsonSchema);
      output += `
        export const ${schemaName} = ${schema}
        export type ${schemaName} = z.infer<typeof ${schemaName}>;
      `;
    }
  }

  await Deno.writeTextFile(outputFile, output);
  console.log(`Generated Zod schemas: ${outputFile}`);

  // Run deno fmt on the generated file
  const command = new Deno.Command("deno", {
    args: ["fmt", outputFile],
  });
  await command.output();
}

main().catch(console.error);
