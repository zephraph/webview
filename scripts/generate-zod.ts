import { walk } from "https://deno.land/std@0.190.0/fs/walk.ts";
import { basename } from "https://deno.land/std@0.190.0/path/mod.ts";
import { match, P } from "npm:ts-pattern";
import type {
  JSONSchema7 as JSONSchema,
  JSONSchema7Definition as JSONSchemaDefinition,
} from "npm:@types/json-schema";

const schemasDir = new URL("../schemas", import.meta.url).pathname;
const outputFile = new URL("../src/schemas.ts", import.meta.url).pathname;

const isDescriminatedUnion = (def: JSONSchemaDefinition[] | undefined) => {
  return def && typeof def[0] === "object" &&
    (def[0]?.required?.[0] + "").startsWith("$");
};

function generateZodSchema(schema: JSONSchema, node?: JSONSchema | boolean) {
  if (!node) {
    node = schema;
  }
  // Work around the fact that JSONSchema7Definition is a union of JSONSchema and boolean
  if (typeof node === "boolean") {
    return "z.boolean()";
  }
  let zodSchema = "";
  const w = (...t: string[]) => {
    zodSchema += t.join(" ");
  };
  const wn = (...t: string[]) => w(...t, "\n");

  match(node)
    .with(
      { type: "boolean" },
      (node) =>
        w(
          "z.boolean()" + (node.default ? `.optional()` : ""),
        ),
    )
    .with({ type: "string", enum: P.array() }, (node) => {
      w(`z.literal("${node.enum[0]}")`);
    })
    .with({ type: "string" }, () => w("z.string()"))
    .with({ $ref: P.select() }, (ref) => {
      const def = ref!.split("/").pop()!;
      w(generateZodSchema(schema, schema.definitions![def]));
    })
    .with({ type: P.array(P.string) }, (node) => {
      w("z");
      for (const type of node.type) {
        match(type)
          .with("boolean", () => w(".boolean()"))
          .with("string", () => w(".string()"))
          .with("null", () => w(".nullable()"))
          .otherwise(() => {
            throw new Error(`Unsupported type: ${type}`);
          });
      }
    })
    .with({
      oneOf: P.when(isDescriminatedUnion),
    }, (node) => {
      // @ts-expect-error This is fine, this code path should never be a boolean
      const [descrim, content = "data"] = node.oneOf[0]?.required;
      const hasContent = node.oneOf?.some((s) =>
        typeof s === "object" && s?.required?.length && s.required.length >= 2
      );
      wn(`z.discriminatedUnion("${descrim}", [`);
      for (const s of node.oneOf ?? []) {
        if (typeof s === "boolean") {
          w(`z.boolean(),`);
          continue;
        }
        w(`z.object({`);
        for (const [key, value] of Object.entries(s.properties!)) {
          w(
            `${key}:`,
            typeof value === "boolean"
              ? value.toString()
              : generateZodSchema(schema, value),
            ",",
          );
        }
        // Ensure content is always defined in descriminated unions that have it
        if (hasContent && !(content in s.properties!)) {
          w(`${content}: z.undefined().optional(),`);
        }
        w(`}),`);
      }
      wn("])");
    })
    .with({ oneOf: P.array() }, (node) => {
      if (node.properties) {
        wn("z.intersection(");
        wn("z.object({");
        for (const [key, value] of Object.entries(node.properties!)) {
          const required = node.required?.includes(key) ?? false;
          w(
            `${key}:`,
            generateZodSchema(schema, value) + (required ? "" : ".optional()"),
            ",",
          );
        }
        wn("}),");
      }
      wn("z.union([");
      for (const s of node.oneOf ?? []) {
        if (typeof s === "boolean") {
          w("z.boolean(),");
          continue;
        }
        w(generateZodSchema(schema, s), ",");
      }
      wn("])");
      if (node.properties) {
        wn(")");
      }
    })
    .with({ anyOf: P.array() }, (node) => {
      wn("z.union([");
      for (const s of node.anyOf ?? []) {
        w(generateZodSchema(schema, s), ",");
      }
      wn("])");
    })
    .with({ type: "object" }, (node) => {
      wn("z.object({");
      for (const [key, value] of Object.entries(node.properties!)) {
        const required = node.required?.includes(key) ?? false;
        w(
          `${key}:`,
          generateZodSchema(schema, value) + (required ? "" : ".optional()"),
          ",",
        );
      }
      wn("})");
    });

  return zodSchema;
}

async function main() {
  let output =
    "// DO NOT EDIT: This file is auto-generated by scripts/generate-zod.ts\n" +
    "import { z } from 'npm:zod';\n\n";

  for await (const entry of walk(schemasDir, { exts: [".json"] })) {
    if (entry.isFile) {
      const jsonSchema: JSONSchema = JSON.parse(
        await Deno.readTextFile(entry.path),
      );
      const schemaName = basename(entry.path, ".json");
      const schema = generateZodSchema(jsonSchema);
      output += `
        export const ${schemaName} = ${schema}
        export type ${schemaName} = z.infer<typeof ${schemaName}>;
      `;
    }
  }

  await Deno.writeTextFile(outputFile, output);
  console.log(`Generated Zod schemas: ${outputFile}`);

  // Run deno fmt on the generated file
  const command = new Deno.Command("deno", {
    args: ["fmt", outputFile],
  });
  await command.output();
}

main().catch(console.error);
